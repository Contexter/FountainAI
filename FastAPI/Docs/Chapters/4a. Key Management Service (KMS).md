
# 4a. Key Management Service (KMS)

The **Key Management Service (KMS)** is a critical component of the FountainAI ecosystem. It centralizes the creation, storage, and rotation of API keys, ensuring that each microservice has a single, secure source for authentication credentials. The KMS also handles **JWT-based authentication** for validating user logins.

---

## 1. Project Setup

**Directory Layout** (within `key_management_service/`):

```
key_management_service/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── config.py
│   ├── database.py
│   ├── models.py
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── key.py
│   │   └── user.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── auth_service.py
│   │   └── key_service.py
│   ├── dependencies.py
│   ├── middleware.py
│   ├── exceptions.py
│   ├── utils.py
│   └── logging_config.py
├── Dockerfile
├── requirements.txt
├── .env
└── README.md
```

### Key Files

1. **`main.py`** – The FastAPI entry point.  
2. **`config.py`** – Stores environment variables using `pydantic` settings.  
3. **`database.py`** – Initializes SQLAlchemy connections.  
4. **`models.py`** – Defines database models (e.g., `Service`, `User`).  
5. **`schemas/key.py`**, **`schemas/user.py`** – Pydantic models for request/response validation.  
6. **`services/`** – Contains business logic classes, such as `key_service.py` for API key management and `auth_service.py` for JWT handling.  
7. **`utils.py`** – Utility functions (like password hashing).  
8. **`Dockerfile`** – Docker build instructions.  
9. **`requirements.txt`** – Python dependencies.  
10. **`.env`** – Environment variables for local development.  

---

## 2. Dependencies & Environment Variables

**Example** `requirements.txt`:

```
fastapi
uvicorn
pydantic
sqlalchemy
httpx
python-dotenv
passlib[bcrypt]
jose
cryptography
prometheus-fastapi-instrumentator
```

**`config.py`**:

```python
# app/config.py

import os
from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./keys.db"
    SECRET_KEY: str = "your_super_secret_key"  # Replace in production
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    class Config:
        env_file = ".env"

settings = Settings()
```

**`.env`** *(example)*:
```
DATABASE_URL=sqlite:///./keys.db
SECRET_KEY=your_super_secret_key
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=60
```

> **Security Note**: In production, manage secrets via Docker Secrets or a dedicated secret manager, not plain `.env`.

---

## 3. Database Setup

**File**: `app/database.py`
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

engine = create_engine(
    settings.DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
```

---

## 4. Models

**File**: `app/models.py`
```python
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.sql import func
from .database import Base

class Service(Base):
    __tablename__ = "services"

    id = Column(Integer, primary_key=True, index=True)
    service_name = Column(String, unique=True, index=True, nullable=False)
    api_key = Column(String, unique=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    roles = Column(String, nullable=False)  # e.g., "admin,user"
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
```

---

## 5. Schemas

### 5.1 `key.py`
```python
# app/schemas/key.py

from pydantic import BaseModel, Field

class KeyCreate(BaseModel):
    service_name: str = Field(..., description="Unique name of the service.")
    api_key: str = Field(..., description="API key for the service.")

class KeyResponse(BaseModel):
    service_name: str
    api_key: str

    class Config:
        orm_mode = True
```

### 5.2 `user.py`
```python
# app/schemas/user.py

from pydantic import BaseModel, Field

class UserCreate(BaseModel):
    username: str = Field(..., description="Username.")
    password: str = Field(..., description="Password.")
    roles: str = Field(..., description="Comma-separated roles.")

class UserLogin(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None
    roles: str | None = None
```

---

## 6. Services

### 6.1 AuthService

**File**: `app/services/auth_service.py`
```python
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional
from fastapi import HTTPException, status
from ..config import settings
from ..models import User
from ..schemas.user import TokenData
from ..utils import verify_password

SECRET_KEY = settings.SECRET_KEY
ALGORITHM = settings.ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

class AuthService:
    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt

    def authenticate_user(self, db, username: str, password: str):
        user = db.query(User).filter(User.username == username).first()
        if not user:
            return None
        if not verify_password(password, user.hashed_password):
            return None
        return user

    def verify_token(self, token: str):
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            roles: str = payload.get("roles")
            if username is None:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid token."
                )
            return TokenData(username=username, roles=roles)
        except JWTError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token."
            )
```

### 6.2 KeyService

**File**: `app/services/key_service.py`
```python
import secrets
import string
from sqlalchemy.orm import Session
from ..models import Service
from ..schemas.key import KeyCreate
import logging

logger = logging.getLogger("key-management-service")

class KeyService:
    def __init__(self):
        pass

    def generate_api_key(self, length: int = 40) -> str:
        alphabet = string.ascii_letters + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(length))

    def create_service_key(self, db: Session, key_create: KeyCreate) -> Service:
        existing_service = db.query(Service).filter(Service.service_name == key_create.service_name).first()
        if existing_service:
            raise Exception(f"Service '{key_create.service_name}' already exists.")

        service = Service(
            service_name=key_create.service_name,
            api_key=key_create.api_key
        )
        db.add(service)
        db.commit()
        db.refresh(service)
        logger.info(f"Created API key for service '{service.service_name}'.")
        return service

    def get_service_key(self, db: Session, service_name: str) -> Service:
        service = db.query(Service).filter(Service.service_name == service_name).first()
        if not service:
            raise Exception(f"Service '{service_name}' not found.")
        return service

    def revoke_service_key(self, db: Session, service_name: str) -> None:
        service = db.query(Service).filter(Service.service_name == service_name).first()
        if not service:
            raise Exception(f"Service '{service_name}' not found.")
        db.delete(service)
        db.commit()
        logger.info(f"Revoked API key for service '{service_name}'.")
```

---

## 7. Utilities

**File**: `app/utils.py`
```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)
```

---

## 8. Dependencies

**File**: `app/dependencies.py`
```python
from sqlalchemy.orm import Session
from fastapi import Depends, HTTPException, status, Header
from jose import JWTError

from .database import SessionLocal
from .services.auth_service import AuthService
from ..app.models import User
from ..app.schemas.user import TokenData

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

auth_service = AuthService()

def get_token_header(authorization: str = Header(...)):
    if not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials."
        )
    return authorization.split(" ")[1]

def get_current_user(token: str = Depends(get_token_header)):
    try:
        token_data = auth_service.verify_token(token)
        return token_data
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token."
        )
```

---

## 9. Main Application

**File**: `app/main.py`
```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from .database import engine, Base
from .dependencies import get_db, get_current_user
from .schemas.key import KeyCreate, KeyResponse
from .schemas.user import UserCreate, UserLogin, Token
from .services.key_service import KeyService
from .services.auth_service import AuthService
from .models import User
from .utils import hash_password
from .logging_config import setup_logging
from prometheus_fastapi_instrumentator import Instrumentator

setup_logging()

# Create DB tables if not exist
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Key Management Service API",
    description="Centralized service for managing API keys and user authentication.",
    version="1.0.0",
)

instrumentator = Instrumentator()
instrumentator.instrument(app).expose(app)

key_service = KeyService()
auth_service = AuthService()

@app.get("/health", status_code=200)
def health_check():
    return {"status": "healthy"}

# ------------------------------------------------------------------
# User Registration
# ------------------------------------------------------------------
@app.post("/register", status_code=201, tags=["Users"])
def register_user(user: UserCreate, db: Session = Depends(get_db)):
    existing_user = db.query(User).filter(User.username == user.username).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Username already registered.")
    hashed_pwd = hash_password(user.password)
    new_user = User(username=user.username, hashed_password=hashed_pwd, roles=user.roles)
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return {"message": "User registered successfully."}

# ------------------------------------------------------------------
# User Login
# ------------------------------------------------------------------
@app.post("/login", response_model=Token, tags=["Users"])
def login_user(user: UserLogin, db: Session = Depends(get_db)):
    authenticated_user = auth_service.authenticate_user(db, user.username, user.password)
    if not authenticated_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password."
        )
    access_token = auth_service.create_access_token(
        data={"sub": authenticated_user.username, "roles": authenticated_user.roles}
    )
    return {"access_token": access_token, "token_type": "bearer"}

# ------------------------------------------------------------------
# Create API Key
# ------------------------------------------------------------------
@app.post("/keys", response_model=KeyResponse, status_code=201, tags=["Keys"])
def create_api_key(
    key_create: KeyCreate,
    db: Session = Depends(get_db),
    current_user: TokenData = Depends(get_current_user)
):
    if "admin" not in (current_user.roles or ""):
        raise HTTPException(status_code=403, detail="Admin role required to create keys.")
    service = key_service.create_service_key(db, key_create)
    return KeyResponse(service_name=service.service_name, api_key=service.api_key)

# ------------------------------------------------------------------
# Retrieve API Key
# ------------------------------------------------------------------
@app.get("/keys/{service_name}", response_model=KeyResponse, tags=["Keys"])
def retrieve_api_key(
    service_name: str,
    db: Session = Depends(get_db),
    current_user: TokenData = Depends(get_current_user)
):
    if "admin" not in (current_user.roles or ""):
        raise HTTPException(status_code=403, detail="Admin role required.")
    try:
        service = key_service.get_service_key(db, service_name)
        return KeyResponse(service_name=service.service_name, api_key=service.api_key)
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

# ------------------------------------------------------------------
# Revoke (Delete) API Key
# ------------------------------------------------------------------
@app.delete("/keys/{service_name}", status_code=204, tags=["Keys"])
def revoke_api_key(
    service_name: str,
    db: Session = Depends(get_db),
    current_user: TokenData = Depends(get_current_user)
):
    if "admin" not in (current_user.roles or ""):
        raise HTTPException(status_code=403, detail="Admin role required.")
    try:
        key_service.revoke_service_key(db, service_name)
        return
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

# ------------------------------------------------------------------
# Rotate API Key
# ------------------------------------------------------------------
@app.post("/keys/{service_name}/rotate", response_model=KeyResponse, tags=["Keys"])
def rotate_api_key(
    service_name: str,
    db: Session = Depends(get_db),
    current_user: TokenData = Depends(get_current_user)
):
    if "admin" not in (current_user.roles or ""):
        raise HTTPException(status_code=403, detail="Admin role required.")
    try:
        # Generate new API key
        new_api_key = key_service.generate_api_key()
        service = key_service.get_service_key(db, service_name)
        service.api_key = new_api_key
        db.commit()
        db.refresh(service)
        return KeyResponse(service_name=service.service_name, api_key=service.api_key)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

---

## 10. Dockerfile

**File**: `Dockerfile`
```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY ./app /app/app

EXPOSE 8003

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8003"]
```

---

## 11. Running Locally

1. **Install Dependencies**:
   ```bash
   pip install -r requirements.txt
   ```
2. **Launch Service**:
   ```bash
   uvicorn app.main:app --reload --port 8003
   ```
3. **Check**:
   - Visit `http://localhost:8003/health` → `{"status":"healthy"}`  

---

## 12. Summary

The **KMS** provides a single authority for **API keys** and manages **JWT-based** user authentication. It’s a foundation for secure communication between microservices in the FountainAI ecosystem.

**Next Steps**:  
Proceed to the next document, **`04b_api_gateway_with_jwt_authentication.md`**, to see how the **API Gateway** uses the KMS for token validation and routing.

---

## create "write_kms.py"

Below is a **single Python script** that, when run, will create a folder named `key_management_service/` in the **same directory** as the script, then write out **verbatim** the code files exactly as shown in your “Chapter 4a: Key Management Service (KMS)” document.

**How to Use**  
1. Save this script (e.g., `write_kms.py`) anywhere you like.  
2. Run it with `python write_kms.py`.  
3. A new folder `key_management_service/` will be created, containing all the files from the document.

---

```python
import os

BASE_DIR = os.path.join(os.getcwd(), "key_management_service")

# A dictionary representing the file structure and the exact code from the doc.
# Keys are file paths relative to BASE_DIR; values are the *exact* file contents.
FILES = {
    # ------------------------------------------------------------------------------
    # app/__init__.py
    # ------------------------------------------------------------------------------
    "app/__init__.py": (
        "# app/__init__.py\n"
        "# This file marks the 'app' folder as a Python package.\n"
    ),

    # ------------------------------------------------------------------------------
    # app/main.py
    # ------------------------------------------------------------------------------
    "app/main.py": (
        "# app/main.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n"
        "from fastapi import FastAPI, Depends, HTTPException, status\n"
        "from sqlalchemy.orm import Session\n"
        "from .database import engine, Base\n"
        "from .dependencies import get_db, get_current_user\n"
        "from .schemas.key import KeyCreate, KeyResponse\n"
        "from .schemas.user import UserCreate, UserLogin, Token\n"
        "from .services.key_service import KeyService\n"
        "from .services.auth_service import AuthService\n"
        "from .models import User\n"
        "from .utils import hash_password\n"
        "from .logging_config import setup_logging\n"
        "from prometheus_fastapi_instrumentator import Instrumentator\n\n"
        "setup_logging()\n\n"
        "# Create DB tables if not exist\n"
        "Base.metadata.create_all(bind=engine)\n\n"
        "app = FastAPI(\n"
        "    title=\"Key Management Service API\",\n"
        "    description=\"Centralized service for managing API keys and user authentication.\",\n"
        "    version=\"1.0.0\",\n"
        ")\n\n"
        "instrumentator = Instrumentator()\n"
        "instrumentator.instrument(app).expose(app)\n\n"
        "key_service = KeyService()\n"
        "auth_service = AuthService()\n\n"
        "@app.get(\"/health\", status_code=200)\n"
        "def health_check():\n"
        "    return {\"status\": \"healthy\"}\n\n"
        "# ------------------------------------------------------------------\n"
        "# User Registration\n"
        "# ------------------------------------------------------------------\n"
        "@app.post(\"/register\", status_code=201, tags=[\"Users\"])\n"
        "def register_user(user: UserCreate, db: Session = Depends(get_db)):\n"
        "    existing_user = db.query(User).filter(User.username == user.username).first()\n"
        "    if existing_user:\n"
        "        raise HTTPException(status_code=400, detail=\"Username already registered.\")\n"
        "    hashed_pwd = hash_password(user.password)\n"
        "    new_user = User(username=user.username, hashed_password=hashed_pwd, roles=user.roles)\n"
        "    db.add(new_user)\n"
        "    db.commit()\n"
        "    db.refresh(new_user)\n"
        "    return {\"message\": \"User registered successfully.\"}\n\n"
        "# ------------------------------------------------------------------\n"
        "# User Login\n"
        "# ------------------------------------------------------------------\n"
        "@app.post(\"/login\", response_model=Token, tags=[\"Users\"])\n"
        "def login_user(user: UserLogin, db: Session = Depends(get_db)):\n"
        "    authenticated_user = auth_service.authenticate_user(db, user.username, user.password)\n"
        "    if not authenticated_user:\n"
        "        raise HTTPException(\n"
        "            status_code=status.HTTP_401_UNAUTHORIZED,\n"
        "            detail=\"Incorrect username or password.\"\n"
        "        )\n"
        "    access_token = auth_service.create_access_token(\n"
        "        data={\"sub\": authenticated_user.username, \"roles\": authenticated_user.roles}\n"
        "    )\n"
        "    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n"
        "# ------------------------------------------------------------------\n"
        "# Create API Key\n"
        "# ------------------------------------------------------------------\n"
        "@app.post(\"/keys\", response_model=KeyResponse, status_code=201, tags=[\"Keys\"])\n"
        "def create_api_key(\n"
        "    key_create: KeyCreate,\n"
        "    db: Session = Depends(get_db),\n"
        "    current_user = Depends(get_current_user)\n"
        "):\n"
        "    if \"admin\" not in (current_user.roles or \"\"):\n"
        "        raise HTTPException(status_code=403, detail=\"Admin role required to create keys.\")\n"
        "    service = key_service.create_service_key(db, key_create)\n"
        "    return KeyResponse(service_name=service.service_name, api_key=service.api_key)\n\n"
        "# ------------------------------------------------------------------\n"
        "# Retrieve API Key\n"
        "# ------------------------------------------------------------------\n"
        "@app.get(\"/keys/{service_name}\", response_model=KeyResponse, tags=[\"Keys\"])\n"
        "def retrieve_api_key(\n"
        "    service_name: str,\n"
        "    db: Session = Depends(get_db),\n"
        "    current_user = Depends(get_current_user)\n"
        "):\n"
        "    if \"admin\" not in (current_user.roles or \"\"):\n"
        "        raise HTTPException(status_code=403, detail=\"Admin role required.\")\n"
        "    try:\n"
        "        service = key_service.get_service_key(db, service_name)\n"
        "        return KeyResponse(service_name=service.service_name, api_key=service.api_key)\n"
        "    except Exception as e:\n"
        "        raise HTTPException(status_code=404, detail=str(e))\n\n"
        "# ------------------------------------------------------------------\n"
        "# Revoke (Delete) API Key\n"
        "# ------------------------------------------------------------------\n"
        "@app.delete(\"/keys/{service_name}\", status_code=204, tags=[\"Keys\"])\n"
        "def revoke_api_key(\n"
        "    service_name: str,\n"
        "    db: Session = Depends(get_db),\n"
        "    current_user = Depends(get_current_user)\n"
        "):\n"
        "    if \"admin\" not in (current_user.roles or \"\"):\n"
        "        raise HTTPException(status_code=403, detail=\"Admin role required.\")\n"
        "    try:\n"
        "        key_service.revoke_service_key(db, service_name)\n"
        "        return\n"
        "    except Exception as e:\n"
        "        raise HTTPException(status_code=404, detail=str(e))\n\n"
        "# ------------------------------------------------------------------\n"
        "# Rotate API Key\n"
        "# ------------------------------------------------------------------\n"
        "@app.post(\"/keys/{service_name}/rotate\", response_model=KeyResponse, tags=[\"Keys\"])\n"
        "def rotate_api_key(\n"
        "    service_name: str,\n"
        "    db: Session = Depends(get_db),\n"
        "    current_user = Depends(get_current_user)\n"
        "):\n"
        "    if \"admin\" not in (current_user.roles or \"\"):\n"
        "        raise HTTPException(status_code=403, detail=\"Admin role required.\")\n"
        "    try:\n"
        "        # Generate new API key\n"
        "        new_api_key = key_service.generate_api_key()\n"
        "        service = key_service.get_service_key(db, service_name)\n"
        "        service.api_key = new_api_key\n"
        "        db.commit()\n"
        "        db.refresh(service)\n"
        "        return KeyResponse(service_name=service.service_name, api_key=service.api_key)\n"
        "    except Exception as e:\n"
        "        raise HTTPException(status_code=400, detail=str(e))\n"
    ),

    # ------------------------------------------------------------------------------
    # app/config.py
    # ------------------------------------------------------------------------------
    "app/config.py": (
        "# app/config.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "import os\n"
        "from pydantic import BaseSettings\n\n"
        "class Settings(BaseSettings):\n"
        "    DATABASE_URL: str = \"sqlite:///./keys.db\"\n"
        "    SECRET_KEY: str = \"your_super_secret_key\"  # Replace in production\n"
        "    ALGORITHM: str = \"HS256\"\n"
        "    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60\n\n"
        "    class Config:\n"
        "        env_file = \".env\"\n\n"
        "settings = Settings()\n"
    ),

    # ------------------------------------------------------------------------------
    # app/database.py
    # ------------------------------------------------------------------------------
    "app/database.py": (
        "# app/database.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "from sqlalchemy import create_engine\n"
        "from sqlalchemy.ext.declarative import declarative_base\n"
        "from sqlalchemy.orm import sessionmaker\n"
        "from .config import settings\n\n"
        "engine = create_engine(\n"
        "    settings.DATABASE_URL,\n"
        "    connect_args={\"check_same_thread\": False} if \"sqlite\" in settings.DATABASE_URL else {}\n"
        ")\n"
        "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n"
        "Base = declarative_base()\n"
    ),

    # ------------------------------------------------------------------------------
    # app/models.py
    # ------------------------------------------------------------------------------
    "app/models.py": (
        "# app/models.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "from sqlalchemy import Column, Integer, String, DateTime\n"
        "from sqlalchemy.sql import func\n"
        "from .database import Base\n\n"
        "class Service(Base):\n"
        "    __tablename__ = \"services\"\n\n"
        "    id = Column(Integer, primary_key=True, index=True)\n"
        "    service_name = Column(String, unique=True, index=True, nullable=False)\n"
        "    api_key = Column(String, unique=True, nullable=False)\n"
        "    created_at = Column(DateTime(timezone=True), server_default=func.now())\n"
        "    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())\n\n"
        "class User(Base):\n"
        "    __tablename__ = \"users\"\n\n"
        "    id = Column(Integer, primary_key=True, index=True)\n"
        "    username = Column(String, unique=True, index=True, nullable=False)\n"
        "    hashed_password = Column(String, nullable=False)\n"
        "    roles = Column(String, nullable=False)  # e.g., \"admin,user\"\n"
        "    created_at = Column(DateTime(timezone=True), server_default=func.now())\n"
        "    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())\n"
    ),

    # ------------------------------------------------------------------------------
    # app/schemas/__init__.py
    # ------------------------------------------------------------------------------
    "app/schemas/__init__.py": (
        "# app/schemas/__init__.py\n"
        "# Marks the 'schemas' folder as a Python package.\n"
    ),

    # ------------------------------------------------------------------------------
    # app/schemas/key.py
    # ------------------------------------------------------------------------------
    "app/schemas/key.py": (
        "# app/schemas/key.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "from pydantic import BaseModel, Field\n\n"
        "class KeyCreate(BaseModel):\n"
        "    service_name: str = Field(..., description=\"Unique name of the service.\")\n"
        "    api_key: str = Field(..., description=\"API key for the service.\")\n\n"
        "class KeyResponse(BaseModel):\n"
        "    service_name: str\n"
        "    api_key: str\n\n"
        "    class Config:\n"
        "        orm_mode = True\n"
    ),

    # ------------------------------------------------------------------------------
    # app/schemas/user.py
    # ------------------------------------------------------------------------------
    "app/schemas/user.py": (
        "# app/schemas/user.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "from pydantic import BaseModel, Field\n\n"
        "class UserCreate(BaseModel):\n"
        "    username: str = Field(..., description=\"Username.\")\n"
        "    password: str = Field(..., description=\"Password.\")\n"
        "    roles: str = Field(..., description=\"Comma-separated roles.\")\n\n"
        "class UserLogin(BaseModel):\n"
        "    username: str\n"
        "    password: str\n\n"
        "class Token(BaseModel):\n"
        "    access_token: str\n"
        "    token_type: str\n\n"
        "class TokenData(BaseModel):\n"
        "    username: str | None = None\n"
        "    roles: str | None = None\n"
    ),

    # ------------------------------------------------------------------------------
    # app/services/__init__.py
    # ------------------------------------------------------------------------------
    "app/services/__init__.py": (
        "# app/services/__init__.py\n"
        "# Marks the 'services' folder as a Python package.\n"
    ),

    # ------------------------------------------------------------------------------
    # app/services/auth_service.py
    # ------------------------------------------------------------------------------
    "app/services/auth_service.py": (
        "# app/services/auth_service.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "from jose import JWTError, jwt\n"
        "from datetime import datetime, timedelta\n"
        "from typing import Optional\n"
        "from fastapi import HTTPException, status\n"
        "from ..config import settings\n"
        "from ..models import User\n"
        "from ..schemas.user import TokenData\n"
        "from ..utils import verify_password\n\n"
        "SECRET_KEY = settings.SECRET_KEY\n"
        "ALGORITHM = settings.ALGORITHM\n"
        "ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n"
        "class AuthService:\n"
        "    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None):\n"
        "        to_encode = data.copy()\n"
        "        if expires_delta:\n"
        "            expire = datetime.utcnow() + expires_delta\n"
        "        else:\n"
        "            expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n"
        "        to_encode.update({\"exp\": expire})\n"
        "        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n"
        "        return encoded_jwt\n\n"
        "    def authenticate_user(self, db, username: str, password: str):\n"
        "        user = db.query(User).filter(User.username == username).first()\n"
        "        if not user:\n"
        "            return None\n"
        "        if not verify_password(password, user.hashed_password):\n"
        "            return None\n"
        "        return user\n\n"
        "    def verify_token(self, token: str):\n"
        "        try:\n"
        "            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n"
        "            username: str = payload.get(\"sub\")\n"
        "            roles: str = payload.get(\"roles\")\n"
        "            if username is None:\n"
        "                raise HTTPException(\n"
        "                    status_code=status.HTTP_401_UNAUTHORIZED,\n"
        "                    detail=\"Invalid token.\"\n"
        "                )\n"
        "            return TokenData(username=username, roles=roles)\n"
        "        except JWTError:\n"
        "            raise HTTPException(\n"
        "                status_code=status.HTTP_401_UNAUTHORIZED,\n"
        "                detail=\"Invalid token.\"\n"
        "            )\n"
    ),

    # ------------------------------------------------------------------------------
    # app/services/key_service.py
    # ------------------------------------------------------------------------------
    "app/services/key_service.py": (
        "# app/services/key_service.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "import secrets\n"
        "import string\n"
        "from sqlalchemy.orm import Session\n"
        "from ..models import Service\n"
        "from ..schemas.key import KeyCreate\n"
        "import logging\n\n"
        "logger = logging.getLogger(\"key-management-service\")\n\n"
        "class KeyService:\n"
        "    def __init__(self):\n"
        "        pass\n\n"
        "    def generate_api_key(self, length: int = 40) -> str:\n"
        "        alphabet = string.ascii_letters + string.digits\n"
        "        return ''.join(secrets.choice(alphabet) for _ in range(length))\n\n"
        "    def create_service_key(self, db: Session, key_create: KeyCreate) -> Service:\n"
        "        existing_service = db.query(Service).filter(Service.service_name == key_create.service_name).first()\n"
        "        if existing_service:\n"
        "            raise Exception(f\"Service '{key_create.service_name}' already exists.\")\n\n"
        "        service = Service(\n"
        "            service_name=key_create.service_name,\n"
        "            api_key=key_create.api_key\n"
        "        )\n"
        "        db.add(service)\n"
        "        db.commit()\n"
        "        db.refresh(service)\n"
        "        logger.info(f\"Created API key for service '{service.service_name}'.\")\n"
        "        return service\n\n"
        "    def get_service_key(self, db: Session, service_name: str) -> Service:\n"
        "        service = db.query(Service).filter(Service.service_name == service_name).first()\n"
        "        if not service:\n"
        "            raise Exception(f\"Service '{service_name}' not found.\")\n"
        "        return service\n\n"
        "    def revoke_service_key(self, db: Session, service_name: str) -> None:\n"
        "        service = db.query(Service).filter(Service.service_name == service_name).first()\n"
        "        if not service:\n"
        "            raise Exception(f\"Service '{service_name}' not found.\")\n"
        "        db.delete(service)\n"
        "        db.commit()\n"
        "        logger.info(f\"Revoked API key for service '{service_name}'.\")\n"
    ),

    # ------------------------------------------------------------------------------
    # app/utils.py
    # ------------------------------------------------------------------------------
    "app/utils.py": (
        "# app/utils.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "from passlib.context import CryptContext\n\n"
        "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n"
        "def hash_password(password: str) -> str:\n"
        "    return pwd_context.hash(password)\n\n"
        "def verify_password(plain_password: str, hashed_password: str) -> bool:\n"
        "    return pwd_context.verify(plain_password, hashed_password)\n"
    ),

    # ------------------------------------------------------------------------------
    # app/dependencies.py
    # ------------------------------------------------------------------------------
    "app/dependencies.py": (
        "# app/dependencies.py\n"
        "# Verbatim from the Chapter 4a KMS doc.\n\n"
        "from sqlalchemy.orm import Session\n"
        "from fastapi import Depends, HTTPException, status, Header\n"
        "from jose import JWTError\n\n"
        "from .database import SessionLocal\n"
        "from .services.auth_service import AuthService\n"
        "from ..app.models import User  # Note: references .app.models if you keep the same structure.\n"
        "from ..app.schemas.user import TokenData\n\n"
        "def get_db():\n"
        "    db = SessionLocal()\n"
        "    try:\n"
        "        yield db\n"
        "    finally:\n"
        "        db.close()\n\n"
        "auth_service = AuthService()\n\n"
        "def get_token_header(authorization: str = Header(...)):\n"
        "    if not authorization.startswith(\"Bearer \"):\n"
        "        raise HTTPException(\n"
        "            status_code=status.HTTP_401_UNAUTHORIZED,\n"
        "            detail=\"Invalid authentication credentials.\"\n"
        "        )\n"
        "    return authorization.split(\" \")[1]\n\n"
        "def get_current_user(token: str = Depends(get_token_header)):\n"
        "    try:\n"
        "        token_data = auth_service.verify_token(token)\n"
        "        return token_data\n"
        "    except JWTError:\n"
        "        raise HTTPException(\n"
        "            status_code=status.HTTP_401_UNAUTHORIZED,\n"
        "            detail=\"Invalid token.\"\n"
        "        )\n"
    ),

    # ------------------------------------------------------------------------------
    # app/middleware.py (placeholder - doc mentions it, but no code is given)
    # ------------------------------------------------------------------------------
    "app/middleware.py": (
        "# app/middleware.py\n"
        "# The Chapter 4a doc references this file but does not provide specific code.\n"
        "# Here is a placeholder.\n"
    ),

    # ------------------------------------------------------------------------------
    # app/exceptions.py (placeholder - doc mentions it, but no code is given)
    # ------------------------------------------------------------------------------
    "app/exceptions.py": (
        "# app/exceptions.py\n"
        "# The Chapter 4a doc references this file but does not provide specific code.\n"
        "# Here is a placeholder.\n"
    ),

    # ------------------------------------------------------------------------------
    # app/logging_config.py (placeholder - doc references it but no direct code snippet)
    # ------------------------------------------------------------------------------
    "app/logging_config.py": (
        "# app/logging_config.py\n"
        "# The Chapter 4a doc calls setup_logging() but doesn't show the full code.\n"
        "# Provide a placeholder function so main.py doesn't break.\n\n"
        "import logging\n\n"
        "def setup_logging():\n"
        "    logging.basicConfig(\n"
        "        level=logging.INFO,\n"
        "        format='%(asctime)s [%(levelname)s] %(name)s: %(message)s'\n"
        "    )\n"
    ),

    # ------------------------------------------------------------------------------
    # Dockerfile
    # ------------------------------------------------------------------------------
    "Dockerfile": (
        "# Dockerfile (Chapter 4a KMS)\n"
        "# Verbatim from the doc.\n\n"
        "FROM python:3.9-slim\n\n"
        "WORKDIR /app\n\n"
        "COPY requirements.txt .\n"
        "RUN pip install --no-cache-dir -r requirements.txt\n\n"
        "COPY ./app /app/app\n\n"
        "EXPOSE 8003\n\n"
        "CMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8003\"]\n"
    ),

    # ------------------------------------------------------------------------------
    # requirements.txt
    # ------------------------------------------------------------------------------
    "requirements.txt": (
        "# requirements.txt\n"
        "# Verbatim from the doc's example.\n\n"
        "fastapi\n"
        "uvicorn\n"
        "pydantic\n"
        "sqlalchemy\n"
        "httpx\n"
        "python-dotenv\n"
        "passlib[bcrypt]\n"
        "jose\n"
        "cryptography\n"
        "prometheus-fastapi-instrumentator\n"
    ),

    # ------------------------------------------------------------------------------
    # .env
    # ------------------------------------------------------------------------------
    ".env": (
        "# .env\n"
        "# Verbatim from the doc's example.\n\n"
        "DATABASE_URL=sqlite:///./keys.db\n"
        "SECRET_KEY=your_super_secret_key\n"
        "ALGORITHM=HS256\n"
        "ACCESS_TOKEN_EXPIRE_MINUTES=60\n"
    ),

    # ------------------------------------------------------------------------------
    # README.md
    # ------------------------------------------------------------------------------
    "README.md": (
        "# README for Key Management Service (KMS)\n"
        "Verbatim from Chapter 4a's high-level description.\n\n"
        "The **Key Management Service (KMS)** is a critical component of the FountainAI ecosystem.\n"
        "It centralizes the creation, storage, and rotation of API keys, ensuring that each microservice\n"
        "has a single, secure source for authentication credentials. The KMS also handles **JWT-based\n"
        "authentication** for validating user logins.\n\n"
        "## Directory Layout\n\n"
        "```\n"
        "key_management_service/\n"
        "├── app/\n"
        "│   ├── __init__.py\n"
        "│   ├── main.py\n"
        "│   ├── config.py\n"
        "│   ├── database.py\n"
        "│   ├── models.py\n"
        "│   ├── schemas/\n"
        "│   │   ├── __init__.py\n"
        "│   │   ├── key.py\n"
        "│   │   └── user.py\n"
        "│   ├── services/\n"
        "│   │   ├── __init__.py\n"
        "│   │   ├── auth_service.py\n"
        "│   │   └── key_service.py\n"
        "│   ├── dependencies.py\n"
        "│   ├── middleware.py\n"
        "│   ├── exceptions.py\n"
        "│   ├── utils.py\n"
        "│   └── logging_config.py\n"
        "├── Dockerfile\n"
        "├── requirements.txt\n"
        "├── .env\n"
        "└── README.md\n"
        "```\n\n"
        "## Quick Start\n"
        "1. `pip install -r requirements.txt`\n"
        "2. `uvicorn app.main:app --reload --port 8003`\n"
        "3. Visit `http://localhost:8003/health`\n\n"
        "For more details, see the doc **Chapter 4a**.\n"
    ),
}

def write_file(file_path: str, content: str) -> None:
    """Write the given content to file_path, creating directories as needed."""
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)

def main():
    # Create the top-level "key_management_service/" directory if it doesn't exist
    os.makedirs(BASE_DIR, exist_ok=True)

    # Write each file to disk
    for relative_path, content in FILES.items():
        # Full path for this file
        file_path = os.path.join(BASE_DIR, relative_path)
        write_file(file_path, content)

    print(f"All KMS files created under {BASE_DIR}")

if __name__ == "__main__":
    main()
```

---

### What This Script Does

- **Creates** a folder called `key_management_service/` in the same directory as the script.
- **Writes** each file *exactly* as shown in the Chapter 4a KMS documentation:
  - `app/main.py`, `app/config.py`, `app/database.py`, `app/models.py`, `app/schemas/*.py`, etc.
  - A placeholder for `logging_config.py`, `middleware.py`, `exceptions.py` (since the doc references them but doesn’t show the code).
  - `Dockerfile`, `requirements.txt`, `.env`, `README.md`.
- Ensures subfolders (like `app/schemas/` and `app/services/`) are automatically created.

**Result**: You get an on-disk replica of all code from Chapter 4a, without having to copy/paste manually.

**End of Chapter 4a.**