>manage and transform directory structures and file contents between textual and filesystem representations
### Problem and Solution Overview
#### Problem Statement:

As an AI language model, I cannot directly interact with the file system to crawl directories and process their contents. However, there are situations where users might need to generate a comprehensive report of their directory structures and file contents or recreate directory structures from a documented format. This need arises in various scenarios, such as:

1. **Documentation**: Developers often need to document the structure and content of their projects for better understanding, sharing, or archiving.
2. **Migration**: When migrating projects, it's useful to have a textual representation that can be easily recreated in a new environment.
3. **Backup and Restore**: Users might want a simple way to back up their directory structure and file contents in a readable format and restore them when needed.
4. **Compliance and Auditing**: Ensures that the directory structure and contents are documented for compliance and auditing purposes.

#### Solution:

To address these needs, we can create two Swift command-line tools:

1. **CodeCrawlerTool**:
    - This tool reads a specified directory and its subdirectories, captures the structure and contents of the files, and generates a Markdown file documenting everything.
    - The output Markdown file provides a tree view of the directory and the content of each file, making it easy to share or archive the project structure.

2. **MarkdownToDirectoryTool**:
    - This tool takes a Markdown file generated by the `CodeCrawlerTool` and reconstructs the directory structure and files on the filesystem.
    - It parses the Markdown to extract directory paths and file contents, then creates the necessary directories and files, populating them with the extracted contents.

### Tool Details and Implementation

#### Project 1: CodeCrawlerTool

**Purpose:** To crawl through a directory and generate a Markdown file containing the directory tree and the contents of each file.

**Implementation Steps:**
1. **Create the Project:**
    ```sh
    swift package init --type executable --name CodeCrawler
    cd CodeCrawler
    ```

2. **Update Package.swift:**
    ```swift
    // swift-tools-version:5.6
    import PackageDescription

    let package = Package(
        name: "CodeCrawler",
        targets: [
            .executableTarget(
                name: "CodeCrawlerTool",
                dependencies: []),
            .testTarget(
                name: "CodeCrawlerTests",
                dependencies: ["CodeCrawlerTool"]),
        ]
    )
    ```

3. **Add the Code in `main.swift`:**
    ```swift
    import Foundation

    /**
     Generates a directory tree structure as a string.

     - Parameters:
        - directory: The URL of the directory to generate the tree structure for.
        - prefix: A prefix string used for formatting the tree structure. Default is an empty string.

     - Returns: A string representing the tree structure of the directory.
     */
    func tree(directory: URL, prefix: String = "") -> String {
        var treeStr = ""
        let contents = (try? FileManager.default.contentsOfDirectory(at: directory, includingPropertiesForKeys: nil, options: []))?.sorted(by: { $0.lastPathComponent.lowercased() < $1.lastPathComponent.lowercased() }) ?? []

        for (index, path) in contents.enumerated() {
            let pointer = index == contents.count - 1 ? "└── " : "├── "
            treeStr += "\(prefix)\(pointer)\(path.lastPathComponent)\n"
            if path.hasDirectoryPath {
                let extensionStr = index == contents.count - 1 ? "    " : "│   "
                treeStr += tree(directory: path, prefix: prefix + extensionStr)
            }
        }

        return treeStr
    }

    /**
     Crawls through the directory and returns the tree structure and file contents.

     - Parameter directory: The URL of the directory to crawl.

     - Returns: A tuple containing a string representing the tree structure and an array of tuples where each tuple contains a file path and its content.
     */
    func crawlDirectory(directory: URL) -> (String, [(String, String)]) {
        let treeStr = tree(directory: directory)
        var fileContents: [(String, String)] = []

        let fileManager = FileManager.default
        if let enumerator = fileManager.enumerator(at: directory, includingPropertiesForKeys: nil) {
            for case let fileURL as URL in enumerator {
                if !fileURL.hasDirectoryPath {
                    if let content = try? String(contentsOf: fileURL, encoding: .utf8) {
                        let relativePath = fileURL.path.replacingOccurrences(of: directory.path + "/", with: "")
                        fileContents.append((relativePath, content))
                    }
                }
            }
        }

        return (treeStr, fileContents)
    }

    /**
     Generates the markdown content from the tree structure and file contents.

     - Parameters:
        - treeStr: The string representing the tree structure.
        - fileContents: An array of tuples where each tuple contains a file path and its content.

     - Returns: A string containing the formatted markdown content.
     */
    func generateMarkdown(treeStr: String, fileContents: [(String, String)]) -> String {
        var mdContent = "# Directory Structure\n\n"
        mdContent += "```\n"
        mdContent += treeStr
        mdContent += "```\n\n"

        for (filePath, content) in fileContents {
            mdContent += "## \(filePath)\n\n"
            mdContent += "```swift\n"
            mdContent += content
            mdContent += "\n```\n\n"
        }

        return mdContent
    }

    /**
     Writes the markdown content to a file.

     - Parameters:
        - content: The string containing the markdown content.
        - outputPath: The URL of the output file.
     */
    func writeMarkdownFile(content: String, to outputPath: URL) {
        do {
            try content.write(to: outputPath, atomically: true, encoding: .utf8)
            print("Markdown file has been generated: \(outputPath.path)")
        } catch {
            print("Failed to write markdown file: \(error.localizedDescription)")
        }
    }

    // Main program execution
    let arguments = CommandLine.arguments
    guard arguments.count == 3 else {
        print("Usage: \(arguments[0]) <directory_path> <output_path>")
        exit(1)
    }

    let directoryPath = arguments[1]
    let outputPath = arguments[2]

    let directoryURL = URL(fileURLWithPath: directoryPath)
    let outputURL = URL(fileURLWithPath: outputPath)

    let (treeStr, fileContents) = crawlDirectory(directory: directoryURL)
    let mdContent = generateMarkdown(treeStr: treeStr, fileContents: fileContents)
    writeMarkdownFile(content: mdContent, to: outputURL)
    ```

4. **Build and Run the Project:**
    ```sh
    swift build
    .build/debug/CodeCrawlerTool /path/to/your/directory /path/to/output.md
    ```

### Project 2: MarkdownToDirectoryTool

**Purpose:** To read a Markdown file containing a directory structure and file contents, and recreate the directory structure and files on the filesystem.

**Implementation Steps:**

1. **Create the Project:**
    ```sh
    swift package init --type executable --name MarkdownToDirectory
    cd MarkdownToDirectory
    ```

2. **Update Package.swift:**
    ```swift
    // swift-tools-version:5.6
    import PackageDescription

    let package = Package(
        name: "MarkdownToDirectory",
        targets: [
            .executableTarget(
                name: "MarkdownToDirectoryTool",
                dependencies: []),
            .testTarget(
                name: "MarkdownToDirectoryTests",
                dependencies: ["MarkdownToDirectoryTool"]),
        ]
    )
    ```

3. **Add the Code in `main.swift`:**
    ```swift
    import Foundation

    /**
     Parses the directory structure from the Markdown content.

     - Parameter markdown: The string containing the Markdown content.

     - Returns: An array of directory paths.
     */
    func parseDirectoryStructure(from markdown: String) -> [String] {
        let lines = markdown.split(separator: "\n")
        var directories = [String]()
        var currentPath = [String]()

        for line in lines {
            if line.hasPrefix("```") || line.isEmpty {
                continue
            }

            let depth = line.prefix { $0 == " " || $0 == "├" || $0 == "└" || $0 == "─" || $0 == "│" }.count / 4
            let directory = line.trimmingCharacters(in: .whitespaces).split(separator: " ").last ?? ""

            if directory.contains(".") { // It's a file
                continue
            }

            if depth < currentPath.count {
                currentPath.removeLast(currentPath.count - depth)
            }

            currentPath.append(String(directory))
            directories.append(currentPath.joined(separator: "/"))
        }

        return directories
    }

    /**
     Parses the file contents from the Markdown content.

     - Parameter markdown: The string containing the Markdown content.

     - Returns: An array of tuples where each tuple contains a file path and its content.
     */
    func parseFileContents(from markdown: String) -> [(String, String)] {
        var fileContents = [(String, String)]()
        let lines = markdown.split(separator: "\n")
        var currentFilePath: String?
        var currentFileContent = [String]()

        for line in lines {
            if line.hasPrefix("##") {
                if let filePath = currentFilePath {
                    fileContents.append((filePath, currentFileContent.joined(separator: "\n")))
                    currentFileContent = []
                }
                currentFilePath = line.trimmingCharacters(in: .whitespaces).replacingOccurrences(of: "## ", with: "")
            } else if line.hasPrefix("```") {
                continue
            } else if let _ = currentFilePath {
                currentFileContent.append(String(line))
            }
        }

        if let filePath = currentFilePath {
            fileContents.append((filePath, currentFileContent.joined(separator: "\n")))
        }

        return fileContents
    }

    /**
     Creates the directory structure.

     - Parameter directories: An array of directory paths.
     */
    func createDirectories(_ directories: [String]) {
        let fileManager = FileManager.default
        for directory in directories {
            try? fileManager.createDirectory(atPath: directory, withIntermediateDirectories: true, attributes: nil)
        }
    }

    /**
     Creates the files with their contents.

     - Parameter fileContents: An array of tuples where each tuple contains a file path and its content.
     */
    func createFiles(_ fileContents: [(String, String)]) {
        for (filePath, content) in fileContents {
            let url = URL(fileURLWithPath: filePath)
            try? content.write(to: url, atomically: true, encoding: .utf8)
        }
    }

    // Main program execution
    let arguments = CommandLine.arguments
    guard arguments.count == 3 else {
        print("Usage: \(arguments[0]) <input_markdown_path> <output_directory_path>")
        exit(1)
    }

    let markdownPath = arguments[1]
    let outputDirectoryPath = arguments[2]

    let markdownURL = URL(fileURLWithPath: markdownPath)
    let outputDirectoryURL = URL(fileURLWithPath: outputDirectoryPath)

    guard let markdownContent = try? String(contentsOf: markdownURL, encoding: .utf8) else {
        print("Failed to read the markdown file at \(markdownPath)")
        exit(1)
    }

    // Change the current directory to the output directory
    FileManager.default.changeCurrentDirectoryPath(outputDirectoryURL.path)

    let directories = parseDirectoryStructure(from: markdownContent)
    let fileContents = parseFileContents(from: markdownContent)

    createDirectories(directories)
    createFiles(fileContents)

    print("Directory structure and files have been created in \(outputDirectoryURL.path)")
    ```

4. **Build and Run the Project:**
    ```sh
    swift build
    .build/debug/MarkdownToDirectoryTool /path/to/input.md /path/to/output/directory
    ```

### Summary

By following the steps above, you will have two fully functional Swift command-line tools:

1. **CodeCrawlerTool:** Reads a directory structure and its files, then generates a Markdown file with the directory tree and file contents.
2. **MarkdownToDirectoryTool:** Reads a Markdown file containing a directory structure and file contents, then recreates the directory structure and files on the filesystem.

Both projects include comprehensive Jazzy-style comments to generate proper documentation. These tools enable users to effectively manage and transform directory structures and file contents between textual and filesystem representations.

### Use Cases for Code Generation, Debugging, and General Guided Application Development

#### Code Generation:
These tools automate the process of creating a comprehensive report of directory structures and file contents, as well as reconstructing those structures from Markdown files. This reduces manual effort and minimizes the chance of human error during documentation or migration tasks.

#### Debugging:
During development, having a textual representation of your project's structure can help identify misplaced files or inconsistencies in the directory hierarchy. The generated Markdown file can be used to quickly review and debug the project's layout.

#### General Guided Application Development:
1. **Documentation:** Automatically generate documentation for your project's structure and contents, making it easier to share with team members or external stakeholders.
2. **Migration:** Use the Markdown representation to migrate projects between different environments or systems, ensuring that the directory structure and file contents are preserved accurately.
3. **Backup and Restore:** Create backups of your project structure and contents in a readable format, and restore them when needed using the MarkdownToDirectoryTool.
4. **Compliance and Auditing:** Maintain accurate records of your project's structure and contents for compliance and auditing purposes. The Markdown file provides a clear and organized view of the project at any given point in time.