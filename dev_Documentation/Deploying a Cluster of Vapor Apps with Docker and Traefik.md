# Learning Path: Deploying a Cluster of Vapor Apps with Docker and Traefik


```
+-----------------------+
| Ubuntu 20.04 VPS       |
|   (Static IP)          |
+-----------------------+
            |
            v
+-----------------------+
| Traefik Proxy          |
| - Routes traffic       |
| - Manages SSL          |
| - Supports Docker      |
|   service discovery    |
+-----------------------+
            |
            v
+-------------------+   +-------------------+
| Vapor App1        |   | Vapor App2        |
| - Docker Container|   | - Docker Container|
| - Port 8081       |   | - Port 8082       |
+-------------------+   +-------------------+
            |                   |
 Routes to app1.example.com   Routes to app2.example.com
```



## Introduction

In this learning path, we'll explore how to set up a cluster of Vapor web applications in a Dockerized environment. These apps are designed based on the OpenAPI specifications provided in the [FountainAI GitHub repository](https://github.com/Contexter/fountainAI/tree/main/openAPI). We'll delve into various aspects of Docker configuration, including creating individual Docker images, orchestrating multi-service setups, and integrating Traefik as a reverse proxy to manage and route traffic to this cluster.

### 1. Docker Configuration Files

#### 1.1 Dockerfile

We'll begin by reviewing the structure and purpose of the Dockerfile generated by the Vapor Toolbox:

- **Build Stage:** We'll understand how it defines the steps to create a Docker image for each Vapor app, including installing dependencies, resolving packages, and compiling the app in a build environment.
- **Run Stage:** We'll see how it sets up a runtime environment, installing necessary libraries, creating a non-root user, and defining how the app runs.

#### 1.2 Docker Compose Configuration

Next, we'll explore the `docker-compose.yaml` file, detailing its role in orchestrating multiple services:

- **Service Definition:** We'll learn how it defines each Vapor app as a separate service, with configurations including port mappings, environment variables, and runtime commands.
- **Testing Focus:** We'll understand how it facilitates testing and development by providing commands to build, start, and stop services collectively.

### 2. Integrating Traefik as a Proxy

Following this, we'll delve into how to integrate Traefik as a reverse proxy for the Vapor app cluster:

- **Traefik Configuration:** We'll see how the `docker-compose.yaml` can be extended to include a Traefik service, which provides routing rules based on Docker labels, entry points for HTTP and HTTPS, and SSL certificate management.
- **Vapor Cluster Setup:** We'll explore how to define multiple Vapor apps in the configuration, setting up labels to route traffic to each app based on OpenAPI specs and managing DNS entries to ensure seamless routing.
- 
### 3. Docker Compose Interactions with External Resources

In this chapter, we'll explore how the docker-compose.yaml configuration makes calls to external resources, ensuring that all necessary images, dependencies, and configurations are available for your Vapor app cluster and Traefik proxy setup.

### Conclusion

By following this learning path, we'll gain a comprehensive understanding of how to deploy a cluster of Vapor web apps in a Dockerized environment. We'll learn to manage individual Docker images and multi-service orchestration with Docker Compose, and explore how to extend this setup with Traefik to manage and route traffic to the cluster based on OpenAPI specifications.

---
## The Dockerfile

```
# ================================
# Build image
# ================================
FROM swift:5.10-jammy as build

# Install OS updates
RUN export DEBIAN_FRONTEND=noninteractive DEBCONF_NONINTERACTIVE_SEEN=true \
    && apt-get -q update \
    && apt-get -q dist-upgrade -y \
    && apt-get install -y libjemalloc-dev

# Set up a build area
WORKDIR /build

# First just resolve dependencies.
# This creates a cached layer that can be reused
# as long as your Package.swift/Package.resolved
# files do not change.
COPY ./Package.* ./
RUN swift package resolve --skip-update \
        $([ -f ./Package.resolved ] && echo "--force-resolved-versions" || true)

# Copy entire repo into container
COPY . .

# Build everything, with optimizations, with static linking, and using jemalloc
# N.B.: The static version of jemalloc is incompatible with the static Swift runtime.
RUN swift build -c release \
                --static-swift-stdlib \
                -Xlinker -ljemalloc

# Switch to the staging area
WORKDIR /staging

# Copy main executable to staging area
RUN cp "$(swift build --package-path /build -c release --show-bin-path)/App" ./

# Copy static swift backtracer binary to staging area
RUN cp "/usr/libexec/swift/linux/swift-backtrace-static" ./

# Copy resources bundled by SPM to staging area
RUN find -L "$(swift build --package-path /build -c release --show-bin-path)/" -regex '.*\.resources$' -exec cp -Ra {} ./ \;

# Copy any resources from the public directory and views directory if the directories exist
# Ensure that by default, neither the directory nor any of its contents are writable.
RUN [ -d /build/Public ] && { mv /build/Public ./Public && chmod -R a-w ./Public; } || true
RUN [ -d /build/Resources ] && { mv /build/Resources ./Resources && chmod -R a-w ./Resources; } || true

# ================================
# Run image
# ================================
FROM ubuntu:jammy

# Make sure all system packages are up to date, and install only essential packages.
RUN export DEBIAN_FRONTEND=noninteractive DEBCONF_NONINTERACTIVE_SEEN=true \
    && apt-get -q update \
    && apt-get -q dist-upgrade -y \
    && apt-get -q install -y \
      libjemalloc2 \
      ca-certificates \
      tzdata \
# If your app or its dependencies import FoundationNetworking, also install `libcurl4`.
      # libcurl4 \
# If your app or its dependencies import FoundationXML, also install `libxml2`.
      # libxml2 \
    && rm -r /var/lib/apt/lists/*

# Create a vapor user and group with /app as its home directory
RUN useradd --user-group --create-home --system --skel /dev/null --home-dir /app vapor

# Switch to the new home directory
WORKDIR /app

# Copy built executable and any staged resources from builder
COPY --from=build --chown=vapor:vapor /staging /app

# Provide configuration needed by the built-in crash reporter and some sensible default behaviors.
ENV SWIFT_BACKTRACE=enable=yes,sanitize=yes,threads=all,images=all,interactive=no,swift-backtrace=./swift-backtrace-static

# Ensure all further commands run as the vapor user
USER vapor:vapor

# Let Docker bind to port 8080
EXPOSE 8080

# Start the Vapor service when the image is run, default to listening on 8080 in production environment
ENTRYPOINT ["./App"]
CMD ["serve", "--env", "production", "--hostname", "0.0.0.0", "--port", "8080"]
```

### Commentary:
This "Dockerfile" is designed to build and run a Vapor web application in a Docker container, and it includes two main stages:

#### Build Image:
1. **Base Image:** Uses `swift:5.10-jammy` as a starting point, which provides Swift 5.10 and is based on Ubuntu 22.04 (Jammy).
2. **OS Updates:** Runs a series of commands to update the OS, upgrade system packages, and install `libjemalloc-dev` for optimized memory management.
3. **Build Area:** Sets `/build` as a working directory for all subsequent build steps.
4. **Dependencies Resolution:** Copies the `Package.*` files into the container and runs `swift package resolve` to resolve package dependencies, with caching in place for reusability.
5. **Copying the Repository:** The entire project repository is copied into the container.
6. **Build:** Compiles the project in release mode with static linking and jemalloc integration for optimized memory management.
7. **Staging Area:** Creates a new working directory `/staging` for preparing the final package.
8. **Copying Executables and Resources:** Moves the compiled executable (`App`), a static backtracer binary, and bundled resources into the staging area. Additional resources from `Public` and `Resources` directories are also moved if they exist.

#### Run Image:
1. **Base Image:** Uses `ubuntu:jammy` to start a fresh runtime environment.
2. **OS Packages:** Updates the OS packages and installs necessary runtime libraries, including `libjemalloc2`.
3. **User Setup:** Creates a new `vapor` user and group with `/app` as its home directory, improving security by avoiding running the app as root.
4. **Staging Directory:** Sets `/app` as the working directory and copies the built resources from the build image.
5. **Environment Variables:** Sets up `SWIFT_BACKTRACE` for crash reporting and backtracing behavior.
6. **Run as Vapor User:** Ensures subsequent commands are run as the `vapor` user.
7. **Port Binding:** Exposes port 8080 to bind the Docker container to the host network.
8. **Entry Point:** Defines `./App` as the executable to run and `CMD` provides default arguments to run the server in production mode.

### Conclusion:
This "Dockerfile" adheres to best practices, providing a secure and efficient setup for deploying a Vapor web application. Key points include:

- **Layered Caching:** Improves build times by caching resolved dependencies and build layers.
- **Security Measures:** Running as a non-root user and configuring resources securely.
- **Separation of Build and Runtime:** Keeps the runtime image slim and free from unnecessary build tools.

## .dockerignore

```
.build/
.swiftpm/
```

### Commentary:

The ".dockerignore" file is a configuration file for Docker, used to specify which files and directories should be ignored when building a Docker image. This can help streamline the build process by reducing unnecessary files and making the resulting image slimmer.

#### Ignored Directories:
1. **`.build/`:**
   - This directory is created by the Swift Package Manager (SPM) to store build artifacts, compiled binaries, and intermediate files.
   - Ignoring this directory ensures that build artifacts are not copied into the Docker image, preventing unnecessary bloat and potential conflicts during the Docker build process.
   - By ignoring these files, you ensure that only necessary files are transferred into the container, making the Docker image smaller and reducing build time.

2. **`.swiftpm/`:**
   - This directory is also created by SPM, containing metadata and information related to the Swift package management process.
   - Ignoring `.swiftpm` ensures that Docker does not transfer this metadata, which is unnecessary for running the compiled application in the container.

#### Benefits of Using ".dockerignore":
- **Efficiency:** By excluding unnecessary files and directories from being copied into the Docker image, the ".dockerignore" file helps reduce the time taken to build the image, as well as its overall size.
- **Security:** Limiting the files and directories copied into the Docker image can also reduce potential security risks, as sensitive information or metadata that might otherwise be included is excluded.
- **Consistency:** This ensures that only essential files are part of the Docker image, which can prevent potential inconsistencies or conflicts during runtime.

### Conclusion:
The ".dockerignore" file in this context effectively excludes build-related directories from being copied into the Docker image, streamlining the build process and preventing unnecessary bloat. This helps create a slimmer, more efficient image that is focused on running the Vapor application securely and consistently.

## docker-compose.yaml

Let's go over the "docker-compose.yaml" file and provide a comprehensive commentary:

```yaml
# Docker Compose file for Vapor
#
# Install Docker on your system to run and test
# your Vapor app in a production-like environment.
#
# Note: This file is intended for testing and does not
# implement best practices for a production deployment.
#
# Learn more: https://docs.docker.com/compose/reference/
#
#   Build images: docker-compose build
#      Start app: docker-compose up app
#       Stop all: docker-compose down
#
version: '3.7'

x-shared_environment: &shared_environment
  LOG_LEVEL: ${LOG_LEVEL:-debug}
  
services:
  app:
    image: server-setup-a-p-i:latest
    build:
      context: .
    environment:
      <<: *shared_environment
    ports:
      - '8080:8080'
    # user: '0' # uncomment to run as root for testing purposes even though Dockerfile defines 'vapor' user.
    command: ["serve", "--env", "production", "--hostname", "0.0.0.0", "--port", "8080"]
```

### Commentary:

This "docker-compose.yaml" file is designed to set up and manage a Docker container for a Vapor application, providing a simplified and efficient way to run and test the app. Let's break down its structure:

#### General Information:
- **Version:** Specifies `version: '3.7'`, which indicates that this configuration uses version 3.7 of Docker Compose syntax.

#### Shared Environment:
- **`x-shared_environment:`** Defines a reusable block of environment variables.
  - **`LOG_LEVEL:`** Specifies a default log level for the application, with a fallback of "debug." This helps set up consistent logging behavior across environments.

#### Services:
- **`app:`** Defines a service for running the Vapor application.
  - **`image:`** Specifies an image to use for this service, which defaults to "server-setup-a-p-i:latest," pointing to the latest built image.
  - **`build:`** Indicates to build the image from the current directory, allowing for custom configurations to be used.
  - **`environment:`** Merges in the shared environment variables block, ensuring consistent configurations for this service.
  - **`ports:`** Maps port 8080 of the container to port 8080 of the host, allowing access to the application.
  - **`command:`** Defines a default command to run the app in production mode, binding to all IP addresses on port 8080.

#### Usage Notes:
- **Testing Focus:** The comments indicate that this configuration is designed primarily for testing and is not necessarily optimized for production deployment.
- **User:** There's an option to run the container as root by uncommenting the `user: '0'` line, though by default, it uses the "vapor" user as specified in the Dockerfile.

#### Usage Commands:
- **`docker-compose build:`** Builds the defined services' images.
- **`docker-compose up app:`** Starts the "app" service, running it based on the configurations provided.
- **`docker-compose down:`** Stops and removes the running services, cleaning up resources.

### Conclusion:
This "docker-compose.yaml" file offers a straightforward setup for managing a Vapor application in a Docker environment, with a focus on testing. Key points include:

- **Consistent Configurations:** Shared environment variables ensure consistent logging and configurations.
- **Port Mapping:** Allows seamless access to the Vapor app by mapping port 8080.
- **Testing Usage:** The configuration is intended for testing, making it easy to spin up and down services for development.

## Why is there a "docker" file AND a "docker-compose.yaml" ? 

The "Dockerfile" and "docker-compose.yaml" serve distinct but complementary roles in managing a Dockerized application. Let's explore the purpose of each file and why both are often used together:

### "Dockerfile":
1. **Purpose:**
   - The "Dockerfile" provides a step-by-step script for creating a Docker image for an application. It defines the base image to use, how to build the application, and how to set up the runtime environment within the image.

2. **Functionality:**
   - **Building:** It compiles the application, installs dependencies, and copies necessary files into the image.
   - **Runtime Configuration:** Specifies how to run the application, including setting environment variables, exposing ports, and defining the default command.

3. **Scope:**
   - The "Dockerfile" focuses on creating an individual image, ensuring that the application is self-contained and ready to run on any system with Docker installed.

### "docker-compose.yaml":
1. **Purpose:**
   - The "docker-compose.yaml" file is used to manage multiple Docker containers, defining how they interact, communicate, and are configured. It provides a higher-level orchestration tool for running complex, multi-service applications.

2. **Functionality:**
   - **Services:** Defines individual services (like the Vapor app and potentially other services such as databases or caches) and specifies how they interact.
   - **Configurations:** Sets up configurations for each service, including environment variables, volumes, networks, and command-line arguments.
   - **Orchestration:** Offers commands to build, start, and stop services collectively, making it easier to manage a multi-service application.

3. **Scope:**
   - The "docker-compose.yaml" focuses on the broader orchestration of multiple containers, enabling services to be configured and managed in unison.

### Why Both Are Needed:
1. **Separation of Concerns:**
   - The "Dockerfile" focuses on building and configuring an individual image, while the "docker-compose.yaml" deals with orchestrating multiple services. This separation helps streamline the process of creating a single image and managing it as part of a larger setup.

2. **Simplified Testing and Deployment:**
   - The "docker-compose.yaml" file provides commands to build, start, and stop services collectively, making it easier to test and deploy multi-service applications, including the Vapor app and any dependencies it might have.

3. **Flexibility:**
   - Having both files provides flexibility in how you manage your application:
      - You can build the Docker image independently using the "Dockerfile."
      - You can then manage how it interacts with other services, including configurations, using "docker-compose.yaml."

### Conclusion:
The "Dockerfile" and "docker-compose.yaml" serve different but complementary roles, providing both a granular way to build individual images and a broader tool for orchestrating multi-service applications. This combination offers a flexible, efficient way to manage Dockerized applications like a Vapor web app, streamlining both development and deployment. 

## Integrate Traefik

Let's explore how to set up a cluster of Vapor apps using Traefik as a reverse proxy. The configuration will be based on the OpenAPI specifications from the specified GitHub repository.

### Steps to Integrate Traefik:

1. **Traefik Overview:**
   - Traefik is a popular reverse proxy and load balancer designed for microservices architectures. It can dynamically route traffic to services based on Docker labels, providing automatic discovery and SSL/TLS support.

2. **Modifying the "docker-compose.yaml":**
   - We need to define the Traefik service and configure each Vapor app to be recognized by Traefik:

```yaml
version: '3.7'

services:
  # Traefik Service
  traefik:
    image: traefik:v2.9
    command:
      - "--api.insecure=true" # Enables the Traefik dashboard for monitoring
      - "--providers.docker=true" # Enables Docker integration for service discovery
      - "--entrypoints.web.address=:80" # Defines an HTTP entry point for incoming traffic
      - "--entrypoints.websecure.address=:443" # Defines an HTTPS entry point for secure traffic
      - "--certificatesresolvers.myresolver.acme.tlschallenge=true" # Enables automatic SSL certificate generation
      - "--certificatesresolvers.myresolver.acme.email=your-email@example.com" # Sets the email for ACME certificates
      - "--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json" # Defines storage for certificates
    ports:
      - '80:80'
      - '443:443'
      - '8080:8080' # Optional: Traefik Dashboard
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock # Traefik accesses Docker daemon for service discovery
      - traefik-certificates:/letsencrypt

  # FountainAI Services
  app1:
    image: fountainai-spec1:latest # Replace with actual image name
    build:
      context: .
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app1.rule=Host(`app1.yourdomain.com`)"
      - "traefik.http.routers.app1.entrypoints=web,websecure"
      - "traefik.http.routers.app1.tls.certresolver=myresolver"
    ports:
      - '8081:8081'

  app2:
    image: fountainai-spec2:latest # Replace with actual image name
    build:
      context: .
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app2.rule=Host(`app2.yourdomain.com`)"
      - "traefik.http.routers.app2.entrypoints=web,websecure"
      - "traefik.http.routers.app2.tls.certresolver=myresolver"
    ports:
      - '8082:8082'

  # Additional services can be defined similarly...

volumes:
  traefik-certificates:
```

3. **Labels for Traefik:**
   - **`traefik.enable`:** Enables Traefik routing for this service.
   - **`traefik.http.routers.appX.rule`:** Defines routing rules, here using host-based routing (`Host(appX.yourdomain.com)`).
   - **`traefik.http.routers.appX.entrypoints`:** Specifies the entry points (HTTP or HTTPS).
   - **`traefik.http.routers.appX.tls.certresolver`:** Links the router to a certificate resolver for automatic SSL certificates.

4. **Dockerfiles for Vapor Apps:**
   - Ensure each Vapor app's Dockerfile is configured to run the app on a distinct port, allowing Traefik to route to each correctly. The "CMD" command might need slight adjustments to specify different ports:

```yaml
CMD ["serve", "--env", "production", "--hostname", "0.0.0.0", "--port", "8081"]
```

5. **Managing DNS:**
   - Ensure DNS entries or aliases are set up to route traffic to Traefik (via IP or domain name), with CNAME records pointing to the appropriate app subdomains.

### Conclusion:
This setup integrates Traefik as a reverse proxy, automatically routing traffic to a cluster of Vapor applications based on OpenAPI specs. The configuration leverages Docker labels for dynamic service discovery, routing rules, and SSL certificate management. Additionally, it provides flexibility to extend further with more services or entry points as needed.



## Docker Compose Interactions with External Resources

In this chapter, we'll explore how the `docker-compose.yaml` configuration makes calls to external resources, ensuring that all necessary images, dependencies, and configurations are available for your Vapor app cluster and Traefik proxy setup.

#### 3.1 Docker Images:
- **Image Retrieval:** Services defined with an `image` tag, such as `traefik:v2.9` or `server-setup-a-p-i:latest`, prompt Docker Compose to check for the image locally. If it's not found, Docker Compose retrieves it from a remote registry, such as Docker Hub, or from another specified repository.
  
#### 3.2 Build Context:
- **Local Builds:** Services defined with a `build` context, such as `context: .`, build the Docker image from the local directory containing a Dockerfile and other necessary files.
- **Network Calls:** During this build process, if dependencies need to be installed or resolved, commands like `apt-get` or `npm install` can trigger network calls to external repositories, such as Ubuntu repositories or npm registries.

#### 3.3 Traefik Configuration:
- **SSL Certificate Requests:** The Traefik service configuration may include options for automatic SSL certificate generation via Let's Encrypt's ACME protocol:
  - `--certificatesresolvers.myresolver.acme.tlschallenge=true`: Enables Traefik to request certificates from Let's Encrypt using TLS-ALPN-01 or HTTP-01 challenges.
  - `--certificatesresolvers.myresolver.acme.email=your-email@example.com`: Specifies the email address to use for Let's Encrypt's account.
  - `--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json`: Defines the storage location for certificates.
- **Network Calls:** These configurations lead to network calls to Let's Encrypt's servers, managing the SSL certificate lifecycle.

#### Conclusion:
This chapter outlines how the `docker-compose.yaml` file interacts with external resources:

- **Image Retrieval:** From remote registries like Docker Hub.
- **Dependency Resolution:** Through network calls to package repositories.
- **SSL Certificate Requests:** Via Let's Encrypt's ACME protocol.

This ensures the necessary resources and configurations are in place for your Vapor app cluster and Traefik proxy, enabling seamless deployments and secure connections.




